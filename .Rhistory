library(dplyr)
library(socialmixr)
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
library(cmdstanr)
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
library(cmdstanr)
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
?check_cmdstan_toolchain
Sys.getenv("PATH")
rtools4x_home_path()
rtools4x_home_path()
library(cmdstanr)
rtools4x_home_path()
library(cmdstanr)
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
cmdstanr::check_cmdstan_toolchain()
cmdstanr::check_cmdstan_toolchain()
library(cmdstanr)
cmdstanr::check_cmdstan_toolchain()
detach("package:cmdstanr", unload = TRUE)
library(cmdstanr)
detach("package:cmdstanr", unload = TRUE)
cmdstanr::check_cmdstan_toolchain()
find_rtools(T)
install.packages("covr")
library(covr)
find_rtools(T)
find_rtools(debug = FALSE)
?find_rtools
detach("package:covr", unload = TRUE)
covr::f
library(pkgbuild)
install.packages("pkgbuild")
find_rtools(debug = FALSE)
library(pkgbuild)
find_rtools(debug = FALSE)
find_rtools(TRUE)
path.expand()
.libPaths()
rtools_path()
check_rtools(debug = FALSE)
Sys.getenv("PATH")
Sys.getenv("HOME")
R.home()
path.expand("~")
file.edit(file.path("~", ".Rprofile"))
library(usethis)
install.packages("usethis")
library(usethis)
usethis::edit_r_environ()
Sys.getenv("PATH")
Sys.setenv("PATH")
?Sys.setenv
print(Sys.setenv(R_TEST = "testit", "A+C" = 123))
Sys.getenv("R_TEST")
print(Sys.setenv(R_TEST = "testit2", "A+C" = 123))
Sys.getenv("R_TEST")
print(Sys.setenv(R_TEST = paste0(Sys.getenv("R_TEST"),";","aaa"), "A+C" = 123))
Sys.getenv("R_TEST")
Sys.unsetenv("R_TEST") # on Unix-alike may warn and not succeed
Sys.getenv("R_TEST", unset = NA)
Sys.unsetenv("R_TEST") # on Unix-alike may warn and not succeed
Sys.getenv("R_TEST")
Sys.unsetenv("A+C") # on Unix-alike may warn and not succeed
Sys.getenv("A+C", unset = NA)
Sys.setenv(PATH = paste0("C:\\rtools42/x86_64-w64-mingw32.static.posix/bin;C:\\rtools42/usr/bin;",Sys.getenv("PATH")))
Sys.getenv("PATH")
library(cmdstanr)
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
library(cmdstanr)
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
Sys.getenv()
Sys.getenv()
Sys.getenv()
getwd()
library("rstantools")
rstan_create_package(path = 'Github/epipool2')
list.files(all.files = TRUE)
getwd()
library("rstantools")
rstan_create_package(path = 'rstanlm')
getwd()
setwd("C:/Users/antho/Documents/Github/poolprev")
library(devtools)
library(roxygen2)
library(devtools);
load_all("."); # Working directory should be in the package SCC_R_package
F_to_C(79);
getwd()
library(devtools);
load_all("."); # Working directory should be in the package SCC_R_package
getwd()
F_to_C(79);
library(roxygen2); # Read in the roxygen2 R package
roxygenise();
?F_to_C;
method="GP"
spec = 1
sens_df = data.frame(n_tot = c(85, 85, 150, 150, 787, 38, 19, 72, 301, 80, 80, 80, 4943, 452, 142, 142, 142, 152, 75, 51),
n_pos = c(78, 64, 138, 126, 751, 30, 18, 64, 226, 73, 74, 77, 4037, 437, 130, 116, 114, 129, 62, 49))
time.pred=NULL
prior=list(lambda=c(0,2),
alpha=c(0,2),
kappa=10,
logit_prev=c(-4,2),
sens=c(85,15))
return.par=FALSE
return.stanfit=FALSE
#check that time is numeric and not a date
#Prior
#default prior (same as in argument)
prior_default=list(lambda=c(0,2), #lengthscale
alpha=c(0,2), #GP standard deviation
kappa=10, #phi parameter
logit_prev=c(-4,2),
sens=c(190,40))
#replace missing element in the user prior by the default prior
prior = c(prior,prior_default[setdiff(names(prior_default),names(prior))])
?data
data("data/data1.rda")
getwd()
data=readRDS("data/data1.rda")
data=readRDS("data/data1.rda")
load("C:/Users/antho/Documents/GitHub/poolprev/data/data1.rda")
View(epipool_data1)
data=epipool_data1[[1]]
data
#check that time is numeric and not a date
#Prior
#default prior (same as in argument)
prior_default=list(lambda=c(0,2), #lengthscale
alpha=c(0,2), #GP standard deviation
kappa=10, #phi parameter
logit_prev=c(-4,2),
sens=c(190,40))
#replace missing element in the user prior by the default prior
prior = c(prior,prior_default[setdiff(names(prior_default),names(prior))])
#remove row with na values
dim.data1 = dim(data)[1]
if(!any(colnames(data)=="pop")){data$pop="pop1"} #create a pop variable with unique population if missing
data = data %>%
dplyr::select(time,pop,n.pools,n.pos.pools,pool.size) %>%
tidyr::drop_na()
library(tidyverse)
data = data %>%
dplyr::select(time,pop,n.pools,n.pos.pools,pool.size) %>%
tidyr::drop_na()
dim.data2 = dim(data)[1]
if(dim.data2<dim.data1){print(paste0(dim.data1-dim.data2, " rows dropped due to missing values"))}
#rank time and calculate number of regions
N=dim(data)[1] #number of observation
t.unique = data$time %>% unique() %>% sort() #distinct time points with data
if(method=="timepoint" & !is.null(time.pred)){stop("Method timepoint cannot make prediction. Select method=GP")}
t.f = c(t.unique,time.pred) %>% unique() %>% sort() #time points on which GP is calculated (could include some prediction point in addition to t_unique)
pop_unique = data$pop %>% unique() %>% sort()
#data
data = data %>%
dplyr::mutate(rank.t = dplyr::dense_rank(time),
pop = as.numeric(factor(pop,levels=pop_unique)))
#matrix indication when using overdispersion parameter phi (and if yes, it indicates the position in the phi vector)
phi_pos = data %>%
dplyr::group_by(pop,rank.t) %>%
dplyr::summarise(n.regions=dplyr::n(),.groups="drop_last") %>%
dplyr::summarise(use_phi = as.numeric(max(n.regions)>1),.groups="drop") %>%
dplyr::arrange(pop) %>%
dplyr::mutate(phi_pos  = dplyr::row_number(use_phi)-sum(use_phi==0)) %>% dplyr::pull(phi_pos)
phi_pos [is.na(phi_pos ) | phi_pos<1] = 0
#stan data
standata = list(N = N, #number of observations
N_t = length(t.f), #number of distinct time points
N_pop = length(pop_unique),
rank_t = structure(data$rank.t,dim=N), #rank of the time point related to the observations
pop = structure(data$pop,dim=N),
t = t.f, #time points where prevalence is calculated (could include prediction for GP)
s = structure(data$pool.size,dim=N), #number of samples by pool
n = structure(as.integer(data$n.pools),dim=N), #number of pools
k = structure(as.integer(data$n.pos.pools),dim=N), #number of positive pools
#data sensitivity specificity
J_sens = dim(sens_df)[1],
y_sens = sens_df$n_pos,
n_sens = sens_df$n_tot,
spec=spec,
#hyperparameters of the priors
p_sens = prior$sens,
p_intercept = prior$logit_prev,
p_lambda = prior$lambda,
p_alpha = prior$alpha,
#overdispersion
N_phi=sum(phi_pos>0),
use_phi=structure(phi_pos,dim=length(pop_unique)),
p_phi = 1/prior$kappa,
#inference
inference=1)
initfun <- function() { list(sens=rbeta(1,standata$p_sens[1],standata$p_sens[2])) }
library(instantiate)
?stan_package_model
standata
stan_package_configure()
fs::dir_tree()
roxygenise()
cmdstanr::cmdstan_path()
.libPaths()
fs::dir_tree()
stan_package_configure()
fs::dir_tree()
stan_package_configure()
stan_package_configure()
roxygenise()
fs::dir_tree()
poolprev()
poolprev
load("C:/Users/antho/Documents/GitHub/poolprev/data/data1.rda")
poolprev(data=epipool_data1)
poolprev(data=epipool_data1[[1]])
method="GP"
spec = 1
sens_df = data.frame(n_tot = c(85, 85, 150, 150, 787, 38, 19, 72, 301, 80, 80, 80, 4943, 452, 142, 142, 142, 152, 75, 51),
n_pos = c(78, 64, 138, 126, 751, 30, 18, 64, 226, 73, 74, 77, 4037, 437, 130, 116, 114, 129, 62, 49))
time.pred=NULL
prior=list(lambda=c(0,2),
alpha=c(0,2),
kappa=10,
logit_prev=c(-4,2),
sens=c(85,15))
return.par=FALSE
return.stanfit=FALSE
#check that time is numeric and not a date
#Prior
#default prior (same as in argument)
prior_default=list(lambda=c(0,2), #lengthscale
alpha=c(0,2), #GP standard deviation
kappa=10, #phi parameter
logit_prev=c(-4,2),
sens=c(190,40))
#replace missing element in the user prior by the default prior
prior = c(prior,prior_default[setdiff(names(prior_default),names(prior))])
#remove row with na values
dim.data1 = dim(data)[1]
if(!any(colnames(data)=="pop")){data$pop="pop1"} #create a pop variable with unique population if missing
data = data %>%
dplyr::select(time,pop,n.pools,n.pos.pools,pool.size) %>%
tidyr::drop_na()
dim.data2 = dim(data)[1]
data=epipool_data1
#replace missing element in the user prior by the default prior
prior = c(prior,prior_default[setdiff(names(prior_default),names(prior))])
prior=list(lambda=c(0,2),
alpha=c(0,2),
kappa=10,
logit_prev=c(-4,2),
sens=c(85,15))
#check that time is numeric and not a date
#Prior
#default prior (same as in argument)
prior_default=list(lambda=c(0,2), #lengthscale
alpha=c(0,2), #GP standard deviation
kappa=10, #phi parameter
logit_prev=c(-4,2),
sens=c(190,40))
#replace missing element in the user prior by the default prior
prior = c(prior,prior_default[setdiff(names(prior_default),names(prior))])
#remove row with na values
dim.data1 = dim(data)[1]
prior
#remove row with na values
dim.data1 = dim(data)[1]
if(!any(colnames(data)=="pop")){data$pop="pop1"} #create a pop variable with unique population if missing
data = data %>%
dplyr::select(time,pop,n.pools,n.pos.pools,pool.size) %>%
tidyr::drop_na()
data
data=epipool_data1[[1]]
#remove row with na values
dim.data1 = dim(data)[1]
dim.data1
if(!any(colnames(data)=="pop")){data$pop="pop1"} #create a pop variable with unique population if missing
data = data %>%
dplyr::select(time,pop,n.pools,n.pos.pools,pool.size) %>%
tidyr::drop_na()
data
dim.data2 = dim(data)[1]
if(dim.data2<dim.data1){print(paste0(dim.data1-dim.data2, " rows dropped due to missing values"))}
#rank time and calculate number of regions
N=dim(data)[1] #number of observation
t.unique = data$time %>% unique() %>% sort() #distinct time points with data
if(method=="timepoint" & !is.null(time.pred)){stop("Method timepoint cannot make prediction. Select method=GP")}
t.f = c(t.unique,time.pred) %>% unique() %>% sort() #time points on which GP is calculated (could include some prediction point in addition to t_unique)
pop_unique = data$pop %>% unique() %>% sort()
#data
data = data %>%
dplyr::mutate(rank.t = dplyr::dense_rank(time),
pop = as.numeric(factor(pop,levels=pop_unique)))
#matrix indication when using overdispersion parameter phi (and if yes, it indicates the position in the phi vector)
phi_pos = data %>%
dplyr::group_by(pop,rank.t) %>%
dplyr::summarise(n.regions=dplyr::n(),.groups="drop_last") %>%
dplyr::summarise(use_phi = as.numeric(max(n.regions)>1),.groups="drop") %>%
dplyr::arrange(pop) %>%
dplyr::mutate(phi_pos  = dplyr::row_number(use_phi)-sum(use_phi==0)) %>% dplyr::pull(phi_pos)
phi_pos [is.na(phi_pos ) | phi_pos<1] = 0
#stan data
standata = list(N = N, #number of observations
N_t = length(t.f), #number of distinct time points
N_pop = length(pop_unique),
rank_t = structure(data$rank.t,dim=N), #rank of the time point related to the observations
pop = structure(data$pop,dim=N),
t = t.f, #time points where prevalence is calculated (could include prediction for GP)
s = structure(data$pool.size,dim=N), #number of samples by pool
n = structure(as.integer(data$n.pools),dim=N), #number of pools
k = structure(as.integer(data$n.pos.pools),dim=N), #number of positive pools
#data sensitivity specificity
J_sens = dim(sens_df)[1],
y_sens = sens_df$n_pos,
n_sens = sens_df$n_tot,
spec=spec,
#hyperparameters of the priors
p_sens = prior$sens,
p_intercept = prior$logit_prev,
p_lambda = prior$lambda,
p_alpha = prior$alpha,
#overdispersion
N_phi=sum(phi_pos>0),
use_phi=structure(phi_pos,dim=length(pop_unique)),
p_phi = 1/prior$kappa,
#inference
inference=1)
initfun <- function() { list(sens=rbeta(1,standata$p_sens[1],standata$p_sens[2])) }
print("Stan")
phi_pos
method
model <- stan_package_model(name = "mod_GP_overdisp", package = "poolprev")
stan_package_model(name = "mod_GP_overdisp", package = "poolprev")
instantiate::stan_package_model_files()
stan_package_compile()
model <- stan_package_model(name = "mod_GP_overdisp", package = "poolprev")
model <- stan_package_model(name = "mod_GP_overdisp", package = "poolprev")
stan_package_compile()
stan_package_compile()
model <- stan_package_model(name = "mod_GP_overdisp", package = "poolprev")
instantiate::stan_package_model_files()
stan_package_compile()
stan_package_compile()
stan_package_configure()
model <- stan_package_model(name = "mod_GP_overdisp", package = "poolprev")
getwd()
install.packages(pkgs = "epipool", type = "source", repos = NULL)
install.packages(pkgs = "C:/Users/antho/Documents/GitHub/poolprev", type = "source", repos = NULL)
poolprev(data=epipool_data1[[1]])
roxygenize()
library(instantiate)
library(roxygen2)
roxygenise()
usethis::use_package("dplyr")
usethis::use_package("instantiate")
usethis::use_package("cmdstanr")
usethis::use_package("ggplot2","Suggests")
roxygenise()
roxygenise()
roxygenise()
load("data/data1.rda")
load("data/data2.rda")
load("data/data3.rda")
data1=epipool_data1
data2=epipool_data2
data3=epipool_data3
data1
data2
data3
usethis::use_data(data1)
usethis::use_data(data2)
usethis::use_data(data3)
roxygenise()
usethis::use_package("tidyr")
usethis::use_package("tibble")
stan_package_configure()
roxygenise()
stan_package_configure()
roxygenise()
roxygenise()
roxygenise()
roxygenise()
stan_package_configure()
roxygenise()
roxygenise()
stan_package_configure()
roxygenise()
?poolprev
pkgload::dev_help('poolprev')
roxygenise()
stan_package_configure()
roxygenise()
stan_package_configure()
stan_package_configure()
roxygenise()
roxygenise()
stan_package_configure()
roxygenise()
roxygenise()
stan_package_configure()
roxygenise()
stan_package_configure()
roxygenise()
roxygenise()
stan_package_configure()
stan_package_configure()
roxygenise()
stan_package_configure()
roxygenise()
roxygenise()
stan_package_configure()
roxygenise()
stan_package_configure()
roxygenise()
stan_package_configure()
roxygenise()
stan_package_configure()
stan_package_configure()
roxygenise()
stan_package_configure()
roxygenise()
source("~/GitHub/poolprev/R/poolprev.R", echo=TRUE)
roxygenise()
stan_package_configure()
roxygenise()
stan_package_configure()
stan_package_configure()
roxygenise()
stan_package_configure()
roxygenise()
roxygenise()
stan_package_configure()
